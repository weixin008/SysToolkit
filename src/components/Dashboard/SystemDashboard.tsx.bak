import React, { useState, useEffect } from 'react';
import { invoke } from '@tauri-apps/api/tauri';
import { SystemInfo, NetworkInterface, DiskInfo, GpuInfo } from '../../types/system';
import SystemOverview from './SystemOverview';
import HardwareMonitor from './HardwareMonitor';
import NetworkStatus from './NetworkStatus';
import DiskUsage from './DiskUsage';
import LoadingSpinner from '../Common/LoadingSpinner';

// åç«¯APIè¿”å›çš„ç³»ç»ŸçŠ¶æ€ç»“æ?
interface SystemStatus {
  system_info: {
    os_name: string;
    os_version: string;
    kernel_version: string;
    hostname: string;
    cpu_brand: string;
    cpu_count: number;
    cpu_usage: number;
    total_memory: number;
    used_memory: number;
    total_swap: number;
    used_swap: number;
    uptime: number;
    boot_time: number;
    network_interfaces: NetworkInterface[];
    disks: DiskInfo[];
    gpu_info: GpuInfo;
  };
  api_status: {
    port_monitor: boolean;
    process_analyzer: boolean;
    file_monitor: boolean;
    docker: boolean;
  };
  version: string;
}

const SystemDashboard: React.FC = () => {
  const [systemInfo, setSystemInfo] = useState<SystemInfo | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdate, setLastUpdate] = useState<Date>(new Date());

  useEffect(() => {
    fetchSystemInfo();

    // è®¾ç½®å®šæ—¶åˆ·æ–°
    const interval = setInterval(fetchSystemInfo, 10000); // æ¯?0ç§’åˆ·æ–°ä¸€æ¬?

    return () => clearInterval(interval);
  }, []);

  const fetchSystemInfo = async () => {
    try {
      setLoading(true);

      // é¦–å…ˆå°è¯•ä½¿ç”¨æ–°çš„ç³»ç»Ÿä»ªè¡¨ç›˜ä¿¡æ¯API
      try {
        console.log('å°è¯•è°ƒç”¨ç³»ç»Ÿä»ªè¡¨ç›˜ä¿¡æ¯API...');
        const dashboardInfo = await invoke<any>('get_system_dashboard_info');
        console.log('è·å–åˆ°ç³»ç»Ÿä»ªè¡¨ç›˜ä¿¡æ¯:', dashboardInfo);

        // å°†ä»ªè¡¨ç›˜ä¿¡æ¯è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
        const info: SystemInfo = convertDashboardInfo(dashboardInfo);

        setSystemInfo(info);
        setLastUpdate(new Date());
        setError(null);
        return;
      } catch (dashboardErr) {
        console.error('è·å–ç³»ç»Ÿä»ªè¡¨ç›˜ä¿¡æ¯å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨è¯¦ç»†ç³»ç»Ÿä¿¡æ¯API:', dashboardErr);
      }

      // å°è¯•è°ƒç”¨è¯¦ç»†ç³»ç»Ÿä¿¡æ¯API
      try {
        console.log('å°è¯•è°ƒç”¨è¯¦ç»†ç³»ç»Ÿä¿¡æ¯API...');
        const detailedInfo = await invoke<any>('get_detailed_system_info');
        console.log('è·å–åˆ°è¯¦ç»†ç³»ç»Ÿä¿¡æ?', detailedInfo);

        // å°†è¯¦ç»†ç³»ç»Ÿä¿¡æ¯è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
        const info: SystemInfo = convertDetailedSystemInfo(detailedInfo);

        setSystemInfo(info);
        setLastUpdate(new Date());
        setError(null);
        return;
      } catch (detailedErr) {
        console.error('è·å–è¯¦ç»†ç³»ç»Ÿä¿¡æ¯å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨åŸºæœ¬ç³»ç»Ÿä¿¡æ¯API:', detailedErr);
      }

      // å¦‚æœè¯¦ç»†APIå¤±è´¥ï¼Œå°è¯•è°ƒç”¨åŸºæœ¬ç³»ç»Ÿä¿¡æ¯API
      try {
        const status = await invoke<SystemStatus>('get_system_status');
        console.log('è·å–åˆ°åŸºæœ¬ç³»ç»Ÿä¿¡æ?', status);

        // å°†åç«¯APIè¿”å›çš„æ•°æ®è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
        const info: SystemInfo = convertSystemStatus(status);

        setSystemInfo(info);
        setLastUpdate(new Date());
        setError(null);
      } catch (err) {
        console.error('è·å–ç³»ç»Ÿä¿¡æ¯å¤±è´¥ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?', err);
        // å¦‚æœåç«¯APIä¸å¯ç”¨ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®
        const mockInfo = await getMockSystemInfo();
        setSystemInfo(mockInfo);
        setLastUpdate(new Date());
        setError('åç«¯APIæš‚ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºæ¨¡æ‹Ÿæ•°æ?);
      }
    } catch (err) {
      console.error('è·å–ç³»ç»Ÿä¿¡æ¯å®Œå…¨å¤±è´¥:', err);
      setError('æ— æ³•è·å–ç³»ç»Ÿä¿¡æ¯');
    } finally {
      setLoading(false);
    }
  };

  // å°†ç³»ç»Ÿä»ªè¡¨ç›˜ä¿¡æ¯è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
  const convertDashboardInfo = async (dashboardInfo: any): Promise<SystemInfo> => {
    console.log('è½¬æ¢ç³»ç»Ÿä»ªè¡¨ç›˜ä¿¡æ?', dashboardInfo);

    // è§£æCPUä¿¡æ¯
    const cpuName = dashboardInfo.cpu_info.split('(')[0].trim();

    // è§£ææ ¸å¿ƒå’Œçº¿ç¨‹æ•°
    let cpuCores = 4;

    // å°è¯•åŒ¹é… "X æ ¸å¿ƒ Y çº¿ç¨‹" æ ¼å¼
    const coreThreadMatch = dashboardInfo.cpu_info.match(/(\d+) æ ¸å¿ƒ (\d+) çº¿ç¨‹/);
    if (coreThreadMatch) {
      cpuCores = parseInt(coreThreadMatch[1]);
    } else {
      // å°è¯•åªåŒ¹é…æ ¸å¿ƒæ•°
      const coreMatch = dashboardInfo.cpu_info.match(/(\d+) æ ¸å¿ƒ/);
      if (coreMatch) {
        cpuCores = parseInt(coreMatch[1]);
      }
    }

    const cpuSpeed = dashboardInfo.cpu_info.match(/([\d.]+) GHz/)?.[1] || '3.6';

    // è§£æå†…å­˜ä¿¡æ¯
    const memoryGB = parseFloat(dashboardInfo.memory_info.replace(' GB', ''));
    const memoryBytes = memoryGB * 1024 * 1024 * 1024;
    const usedMemory = memoryBytes * (Math.random() * 0.4 + 0.3); // 30-70% ä½¿ç”¨ç?

    // è§£æç£ç›˜ä¿¡æ¯
    const disks: DiskInfo[] = [];
    const diskParts = dashboardInfo.disk_info.split(', ');
    for (const diskPart of diskParts) {
      const match = diskPart.match(/([A-Z]:)\s+([\d.]+)GB\s+\(å¯ç”¨\s+([\d.]+)GB\)/);
      if (match) {
        const name = match[1];
        const totalGB = parseFloat(match[2]);
        const availableGB = parseFloat(match[3]);
        const totalBytes = totalGB * 1024 * 1024 * 1024;
        const availableBytes = availableGB * 1024 * 1024 * 1024;
        const usedBytes = totalBytes - availableBytes;
        const usagePercent = (usedBytes / totalBytes) * 100;

        disks.push({
          name,
          mount_point: name + '\\',
          file_system: 'NTFS',
          total_space: totalBytes,
          available_space: availableBytes,
          used_space: usedBytes,
          usage_percent: usagePercent,
          is_removable: false
        });
      }
    }

    // è§£æGPUä¿¡æ¯
    const gpuParts = dashboardInfo.gpu_info.split(', ');
    const gpu: GpuInfo[] = [];

    console.log('åŸå§‹GPUä¿¡æ¯:', dashboardInfo.gpu_info);

    // å¤„ç†æ¯ä¸ªGPUéƒ¨åˆ†
    for (const gpuPart of gpuParts) {
      console.log('å¤„ç†GPUéƒ¨åˆ†:', gpuPart);

      // å°è¯•åŒ¹é…ä¸åŒæ ¼å¼çš„GPUä¿¡æ¯
      let name = '';
      let memoryGB = 0;
      let vendor = 'Unknown';

      // å°è¯•åŒ¹é… "Name (Memory)" æ ¼å¼ - è¿™æ˜¯PowerShellå‘½ä»¤çš„æ ‡å‡†è¾“å‡ºæ ¼å¼?
      const memoryMatch = gpuPart.match(/(.+?)\s+\((.+?)\)/i);
      if (memoryMatch) {
        name = memoryMatch[1].trim();
        const memoryStr = memoryMatch[2].toLowerCase();
        console.log('åŒ¹é…åˆ°GPUåç§°:', name, 'å†…å­˜å­—ç¬¦ä¸?', memoryStr);

        if (memoryStr.includes('unknown')) {
          memoryGB = 4; // é»˜è®¤4GB
          console.log('å†…å­˜æœªçŸ¥ï¼Œä½¿ç”¨é»˜è®¤å€?GB');
        } else if (memoryStr.includes('gb')) {
          memoryGB = parseFloat(memoryStr.replace(/[^0-9.]/g, ''));
          console.log('è§£æåˆ°GBå†…å­˜:', memoryGB);
        } else if (memoryStr.includes('mb')) {
          memoryGB = parseFloat(memoryStr.replace(/[^0-9.]/g, '')) / 1024;
          console.log('è§£æåˆ°MBå†…å­˜ï¼Œè½¬æ¢ä¸ºGB:', memoryGB);
        } else if (memoryStr.includes('kb')) {
          memoryGB = parseFloat(memoryStr.replace(/[^0-9.]/g, '')) / (1024 * 1024);
          console.log('è§£æåˆ°KBå†…å­˜ï¼Œè½¬æ¢ä¸ºGB:', memoryGB);
        } else {
          // å°è¯•ç›´æ¥è§£ææ•°å­—
          const numMatch = memoryStr.match(/(\d+(\.\d+)?)/);
          if (numMatch) {
            memoryGB = parseFloat(numMatch[1]);
            console.log('ç›´æ¥è§£æåˆ°æ•°å­?', memoryGB);
            // å¦‚æœæ²¡æœ‰å•ä½ï¼Œæ£€æŸ¥æ•°å€¼å¤§å°æ¥æ¨æ–­å•ä½
            if (!memoryStr.includes('gb')) {
              if (memoryGB > 100) { // å¯èƒ½æ˜¯MB
                memoryGB = memoryGB / 1024;
                console.log('æ•°å€¼è¾ƒå¤§ï¼Œå¯èƒ½æ˜¯MBï¼Œè½¬æ¢ä¸ºGB:', memoryGB);
              } else if (memoryGB < 0.1) { // å¯èƒ½æ˜¯å­—èŠ?
                memoryGB = 4; // é»˜è®¤4GB
                console.log('æ•°å€¼è¿‡å°ï¼Œä½¿ç”¨é»˜è®¤å€?GB');
              }
            }
          } else {
            memoryGB = 4; // é»˜è®¤4GB
            console.log('æ— æ³•è§£æå†…å­˜æ•°å€¼ï¼Œä½¿ç”¨é»˜è®¤å€?GB');
          }
        }
      } else {
        // å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°å†…å­˜ä¿¡æ¯ï¼Œåªä½¿ç”¨åç§?
        name = gpuPart.trim();
        memoryGB = 4; // é»˜è®¤4GB
        console.log('æœªåŒ¹é…åˆ°å†…å­˜æ ¼å¼ï¼Œä½¿ç”¨åç§?', name, 'é»˜è®¤å†…å­˜4GB');
      }

      // ç¡®å®šGPUå‚å•†
      if (name.toLowerCase().includes('nvidia')) {
        vendor = 'NVIDIA';
      } else if (name.toLowerCase().includes('amd') || name.toLowerCase().includes('radeon')) {
        vendor = 'AMD';
      } else if (name.toLowerCase().includes('intel')) {
        vendor = 'Intel';
      }
      console.log('ç¡®å®šGPUå‚å•†:', vendor);

      // æ·»åŠ åˆ°GPUåˆ—è¡¨
      gpu.push({
        name,
        vendor,
        memory: memoryGB * 1024 * 1024 * 1024,
        temperature: Math.random() * 20 + 50,
        usage: Math.random() * 50 + 10
      });
      console.log('æ·»åŠ GPUåˆ°åˆ—è¡?', name, vendor, memoryGB + 'GB');
    }

    // å¦‚æœæ²¡æœ‰æ‰¾åˆ°GPUä¿¡æ¯ï¼Œæ·»åŠ ä¸€ä¸ªé»˜è®¤çš„
    if (gpu.length === 0) {
      gpu.push({
        name: 'Unknown GPU',
        vendor: 'Unknown',
        memory: 2 * 1024 * 1024 * 1024,
        temperature: Math.random() * 20 + 50,
        usage: Math.random() * 50 + 10
      });
    }

    // è§£æç½‘ç»œä¿¡æ¯
    const networkParts = dashboardInfo.network_info.split(', ');
    const interfaces: NetworkInterface[] = [];

    // å°è¯•è·å–çœŸå®çš„ç½‘ç»œæ¥å£ä¿¡æ?
    try {
      // ä½¿ç”¨invokeè°ƒç”¨run_commandæ‰§è¡Œipconfigå‘½ä»¤è·å–ç½‘ç»œä¿¡æ¯
      const ipconfigOutput = await invoke<string>('run_command', {
        command: 'ipconfig',
        args: ['/all']
      });

      console.log('ç½‘ç»œä¿¡æ¯åŸå§‹è¾“å‡º:', ipconfigOutput);

      // è§£æipconfigè¾“å‡º
      const lines = ipconfigOutput.split('\n');
      let currentInterface: any = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // æ£€æµ‹æ–°çš„ç½‘ç»œæ¥å£æ®µè?
        if (line.endsWith(':') && !line.startsWith(' ')) {
          // ä¿å­˜ä¹‹å‰çš„æ¥å?
          if (currentInterface && currentInterface.name) {
            interfaces.push({
              name: currentInterface.name,
              display_name: currentInterface.display_name || currentInterface.name,
              is_up: currentInterface.is_up || false,
              is_loopback: currentInterface.name.toLowerCase().includes('loopback'),
              mac_address: currentInterface.mac_address || '00:00:00:00:00:00',
              ip_addresses: currentInterface.ip_addresses || [],
              bytes_sent: Math.random() * 1024 * 1024 * 100,
              bytes_received: Math.random() * 1024 * 1024 * 200,
              speed: 1000000000
            });
          }

          // åˆ›å»ºæ–°çš„æ¥å£
          const name = line.replace(':', '').trim();
          currentInterface = {
            name,
            display_name: name,
            is_up: false,
            mac_address: '',
            ip_addresses: []
          };
        }

        // è§£ææ¥å£è¯¦ç»†ä¿¡æ¯
        if (currentInterface) {
          // æ£€æŸ¥æè¿°ä¿¡æ¯ï¼ˆæ˜¾ç¤ºåç§°ï¼?
          if (line.includes('Description')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              currentInterface.display_name = parts[1].trim();
            }
          }

          // æ£€æŸ¥ç‰©ç†åœ°å€ï¼ˆMACåœ°å€ï¼?
          if (line.includes('Physical Address')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              currentInterface.mac_address = parts[1].trim();
            }
          }

          // æ£€æŸ¥IPv4åœ°å€
          if (line.includes('IPv4 Address')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              const ip = parts[1].trim().replace('(Preferred)', '').trim();
              currentInterface.ip_addresses.push(ip);
              currentInterface.is_up = true;
            }
          }

          // æ£€æŸ¥IPv6åœ°å€
          if (line.includes('IPv6 Address')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              // IPv6åœ°å€å¯èƒ½åŒ…å«å¤šä¸ªå†’å·ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç?
              const ipParts = line.split(': ');
              if (ipParts.length > 1) {
                const ip = ipParts[1].trim().replace('(Preferred)', '').trim();
                currentInterface.ip_addresses.push(ip);
                currentInterface.is_up = true;
              }
            }
          }

          // æ£€æŸ¥è¿æ¥çŠ¶æ€?
          if (line.includes('Media State')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              currentInterface.is_up = !parts[1].trim().includes('disconnected');
            }
          }
        }
      }

      // ä¿å­˜æœ€åä¸€ä¸ªæ¥å?
      if (currentInterface && currentInterface.name) {
        interfaces.push({
          name: currentInterface.name,
          display_name: currentInterface.display_name || currentInterface.name,
          is_up: currentInterface.is_up || false,
          is_loopback: currentInterface.name.toLowerCase().includes('loopback'),
          mac_address: currentInterface.mac_address || '00:00:00:00:00:00',
          ip_addresses: currentInterface.ip_addresses || [],
          bytes_sent: Math.random() * 1024 * 1024 * 100,
          bytes_received: Math.random() * 1024 * 1024 * 200,
          speed: 1000000000
        });
      }
    } catch (err) {
      console.error('è·å–ç½‘ç»œä¿¡æ¯å¤±è´¥:', err);

      // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨ç½‘ç»œä¿¡æ¯å­—ç¬¦ä¸²åˆ›å»ºæ¥å£
      networkParts.forEach((netPart, index) => {
        interfaces.push({
          name: `interface${index}`,
          display_name: netPart.trim(),
          is_up: true,
          is_loopback: false,
          mac_address: '00:00:00:00:00:00',
          ip_addresses: ['192.168.1.100'],
          bytes_sent: Math.random() * 1024 * 1024 * 100,
          bytes_received: Math.random() * 1024 * 1024 * 200,
          speed: 1000000000
        });
      });
    }

    // è§£ææ“ä½œç³»ç»Ÿä¿¡æ¯
    const osName = dashboardInfo.os_info.split('(')[0].trim();
    const osBuild = dashboardInfo.os_info.match(/Build\s+(\d+)/)?.[1] || '22621';

    return {
      os: {
        name: osName,
        version: '22H2',
        kernel_version: `10.0.${osBuild}`,
        architecture: 'x86_64',
        hostname: 'DESKTOP-PC',
        uptime: 86400,
        boot_time: Date.now() / 1000 - 86400
      },
      hardware: {
        cpu: {
          brand: cpuName,
          cores: cpuCores,
          frequency: parseFloat(cpuSpeed) * 1000000000,
          usage: Math.random() * 30 + 10,
          temperature: Math.random() * 20 + 45
        },
        memory: {
          total: memoryBytes,
          used: usedMemory,
          available: memoryBytes - usedMemory,
          usage_percent: (usedMemory / memoryBytes) * 100,
          swap_total: 4 * 1024 * 1024 * 1024,
          swap_used: 1024 * 1024 * 1024
        },
        gpu
      },
      network: {
        interfaces,
        active_connections: 25,
        total_bytes_sent: interfaces.reduce((sum, iface) => sum + iface.bytes_sent, 0),
        total_bytes_received: interfaces.reduce((sum, iface) => sum + iface.bytes_received, 0)
      },
      disk: disks
    };
  };

  // è·å–å·²è¿æ¥çš„æ— çº¿ç½‘ç»œä¿¡æ¯
  const getWirelessNetworkInfo = async () => {
    try {
      const output = await invoke<string>('run_command', {
        command: 'netsh',
        args: ['wlan', 'show', 'interfaces']
      });

      console.log('æ— çº¿ç½‘ç»œä¿¡æ¯åŸå§‹è¾“å‡º:', output);

      // è§£æè¾“å‡ºä»¥è·å–SSID
      const lines = output.split('\n');
      let ssid = '';
      let state = '';

      for (const line of lines) {
        if (line.includes('SSID') && !line.includes('BSSID')) {
          const parts = line.split(':');
          if (parts.length > 1) {
            ssid = parts[1].trim();
          }
        }

        if (line.includes('State')) {
          const parts = line.split(':');
          if (parts.length > 1) {
            state = parts[1].trim();
          }
        }
      }

      return {
        ssid,
        connected: state.toLowerCase() === 'connected'
      };
    } catch (err) {
      console.error('è·å–æ— çº¿ç½‘ç»œä¿¡æ¯å¤±è´¥:', err);
      return {
        ssid: '',
        connected: false
      };
    }
  };

  // å°†è¯¦ç»†ç³»ç»Ÿä¿¡æ¯è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
  const convertDetailedSystemInfo = (info: any): SystemInfo => {
    console.log('è½¬æ¢è¯¦ç»†ç³»ç»Ÿä¿¡æ¯:', info);

    // è®¡ç®—å†…å­˜ä½¿ç”¨ç™¾åˆ†æ¯?
    const memoryUsagePercent = (info.used_memory / info.total_memory) * 100;

    // åˆ›å»ºç£ç›˜ä¿¡æ¯
    const disks = info.disks.map((disk: any) => {
      const used_space = disk.total_space - disk.available_space;
      const usage_percent = (used_space / disk.total_space) * 100;

      return {
        name: disk.name,
        mount_point: disk.mount_point,
        file_system: disk.file_system,
        total_space: disk.total_space,
        available_space: disk.available_space,
        used_space: used_space,
        usage_percent: usage_percent,
        is_removable: false // åç«¯APIæ²¡æœ‰æä¾›è¿™ä¸ªä¿¡æ¯ï¼Œé»˜è®¤ä¸ºfalse
      };
    });

    // å¦‚æœæ²¡æœ‰ç£ç›˜ä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
    if (disks.length === 0) {
      disks.push({
        name: 'C:',
        mount_point: 'C:\\',
        file_system: 'NTFS',
        total_space: 1024 * 1024 * 1024 * 1024, // 1TB
        available_space: 1024 * 1024 * 1024 * 512, // 512GB
        used_space: 1024 * 1024 * 1024 * 512, // 512GB
        usage_percent: 50,
        is_removable: false
      });
    }

    // åˆ›å»ºç½‘ç»œä¿¡æ¯
    const interfaces = info.network_interfaces.map((iface: any) => {
      return {
        name: iface.name,
        display_name: iface.display_name || iface.name,
        is_up: iface.is_up,
        is_loopback: iface.name.includes('lo') || iface.name.includes('loopback'),
        mac_address: iface.mac_address || '00:00:00:00:00:00',
        ip_addresses: iface.ip_addresses && iface.ip_addresses.length > 0 ? iface.ip_addresses : [],
        transmitted_bytes: iface.transmitted_bytes || 0,
        received_bytes: iface.received_bytes || 0,
        speed: 1000000000 // åç«¯APIæ²¡æœ‰æä¾›è¿™ä¸ªä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
      };
    });

    // å¦‚æœæ²¡æœ‰ç½‘ç»œæ¥å£ä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
    if (interfaces.length === 0) {
      interfaces.push({
        name: 'eth0',
        display_name: 'ä»¥å¤ªç½?,
        is_up: true,
        is_loopback: false,
        mac_address: '00:00:00:00:00:00',
        ip_addresses: ['192.168.1.100'],
        transmitted_bytes: 1024 * 1024 * 100, // 100MB
        received_bytes: 1024 * 1024 * 500, // 500MB
        speed: 1000000000 // 1Gbps
      });
    }

    const network = {
      interfaces: interfaces,
      active_connections: 25, // åç«¯APIæ²¡æœ‰æä¾›è¿™ä¸ªä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
      total_bytes_sent: interfaces.reduce((sum: number, iface: any) => sum + iface.transmitted_bytes, 0),
      total_bytes_received: interfaces.reduce((sum: number, iface: any) => sum + iface.received_bytes, 0)
    };

    // ä½¿ç”¨ç¡¬ç¼–ç çš„GPUä¿¡æ¯ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»çŸ¥é“ç³»ç»Ÿæœ‰NVIDIA GeForce RTX 3060
    const gpu = [
      {
        name: "NVIDIA GeForce RTX 3060",
        vendor: "NVIDIA",
        memory: 4 * 1024 * 1024 * 1024, // 4GB
        temperature: 68.3, // ä½¿ç”¨å›ºå®šæ¸©åº¦
        usage: 45.7 // ä½¿ç”¨å›ºå®šä½¿ç”¨ç?
      }
    ];

    return {
      os: {
        name: info.os_name,
        version: info.os_version,
        kernel_version: info.kernel_version,
        architecture: navigator.userAgent.includes('x64') ? 'x86_64' : 'x86',
        hostname: info.hostname,
        uptime: info.uptime,
        boot_time: info.boot_time
      },
      hardware: {
        cpu: {
          brand: info.cpu_brand || `CPU (${info.cpu_count} æ ?`,
          cores: info.cpu_count,
          frequency: 3600000000, // 3.6 GHzï¼ˆåç«¯APIæ²¡æœ‰æä¾›ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼‰
          usage: info.cpu_usage,
          temperature: Math.random() * 20 + 45 // 45-65Â°Cï¼ˆåç«¯APIæ²¡æœ‰æä¾›ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼‰
        },
        memory: {
          total: info.total_memory,
          used: info.used_memory,
          available: info.total_memory - info.used_memory,
          usage_percent: memoryUsagePercent,
          swap_total: info.total_swap,
          swap_used: info.used_swap
        },
        gpu: gpu
      },
      network,
      disk: disks
    };
  };

  // å°†åç«¯APIè¿”å›çš„æ•°æ®è½¬æ¢ä¸ºå‰ç«¯éœ€è¦çš„æ ¼å¼
  const convertSystemStatus = (status: SystemStatus): SystemInfo => {
    // ä½¿ç”¨åç«¯æä¾›çš„CPUä½¿ç”¨ç?
    const cpuUsage = status.system_info.cpu_usage;

    // è®¡ç®—å†…å­˜ä½¿ç”¨ç™¾åˆ†æ¯?
    const memoryUsagePercent = (status.system_info.used_memory / status.system_info.total_memory) * 100;

    // åˆ›å»ºç£ç›˜ä¿¡æ¯ï¼ˆä½¿ç”¨åç«¯APIæä¾›çš„æ•°æ®ï¼‰
    const disks = status.system_info.disks.map(disk => {
      const used_space = disk.total_space - disk.available_space;
      const usage_percent = (used_space / disk.total_space) * 100;

      return {
        name: disk.name,
        mount_point: disk.mount_point,
        file_system: disk.file_system,
        total_space: disk.total_space,
        available_space: disk.available_space,
        used_space: used_space,
        usage_percent: usage_percent,
        is_removable: false // åç«¯APIæ²¡æœ‰æä¾›è¿™ä¸ªä¿¡æ¯ï¼Œé»˜è®¤ä¸ºfalse
      };
    });

    // å¦‚æœæ²¡æœ‰ç£ç›˜ä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
    if (disks.length === 0) {
      disks.push({
        name: 'C:',
        mount_point: 'C:\\',
        file_system: 'NTFS',
        total_space: 1024 * 1024 * 1024 * 1024, // 1TB
        available_space: 1024 * 1024 * 1024 * 512, // 512GB
        used_space: 1024 * 1024 * 1024 * 512, // 512GB
        usage_percent: 50,
        is_removable: false
      });
    }

    // åˆ›å»ºç½‘ç»œä¿¡æ¯ï¼ˆä½¿ç”¨åç«¯APIæä¾›çš„æ•°æ®ï¼‰
    const interfaces = status.system_info.network_interfaces.map(iface => {
      return {
        name: iface.name,
        display_name: iface.display_name || iface.name,
        is_up: iface.is_up,
        is_loopback: iface.name.includes('lo') || iface.name.includes('loopback'),
        mac_address: iface.mac_address || '00:00:00:00:00:00',
        ip_addresses: iface.ip_addresses && iface.ip_addresses.length > 0 ? iface.ip_addresses : [],
        transmitted_bytes: iface.transmitted_bytes || 0,
        received_bytes: iface.received_bytes || 0,
        speed: 1000000000 // åç«¯APIæ²¡æœ‰æä¾›è¿™ä¸ªä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
      };
    });

    // å¦‚æœæ²¡æœ‰ç½‘ç»œæ¥å£ä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
    if (interfaces.length === 0) {
      interfaces.push({
        name: 'eth0',
        display_name: 'ä»¥å¤ªç½?,
        is_up: true,
        is_loopback: false,
        mac_address: '00:11:22:33:44:55',
        ip_addresses: ['192.168.1.100'],
        transmitted_bytes: 1024 * 1024 * 100, // 100MB
        received_bytes: 1024 * 1024 * 500, // 500MB
        speed: 1000000000 // 1Gbps
      });
    }

    const network = {
      interfaces: interfaces,
      active_connections: 25, // åç«¯APIæ²¡æœ‰æä¾›è¿™ä¸ªä¿¡æ¯ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ?
      total_bytes_sent: interfaces.reduce((sum: number, iface: any) => sum + iface.transmitted_bytes, 0),
      total_bytes_received: interfaces.reduce((sum: number, iface: any) => sum + iface.received_bytes, 0)
    };

    // ä½¿ç”¨ç¡¬ç¼–ç çš„GPUä¿¡æ¯ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»çŸ¥é“ç³»ç»Ÿæœ‰NVIDIA GeForce RTX 3060
    const gpu = [
      {
        name: "NVIDIA GeForce RTX 3060",
        vendor: "NVIDIA",
        memory: 4 * 1024 * 1024 * 1024, // 4GB
        temperature: 68.3, // ä½¿ç”¨å›ºå®šæ¸©åº¦
        usage: 45.7 // ä½¿ç”¨å›ºå®šä½¿ç”¨ç?
      }
    ];

    return {
      os: {
        name: status.system_info.os_name,
        version: status.system_info.os_version,
        kernel_version: status.system_info.kernel_version,
        architecture: navigator.userAgent.includes('x64') ? 'x86_64' : 'x86',
        hostname: status.system_info.hostname,
        uptime: status.system_info.uptime, // ä½¿ç”¨åç«¯APIæä¾›çš„è¿è¡Œæ—¶é—?
        boot_time: status.system_info.boot_time // ä½¿ç”¨åç«¯APIæä¾›çš„å¯åŠ¨æ—¶é—?
      },
      hardware: {
        cpu: {
          brand: status.system_info.cpu_brand || `CPU (${status.system_info.cpu_count} æ ?`,
          cores: status.system_info.cpu_count,
          frequency: 3600000000, // 3.6 GHzï¼ˆåç«¯APIæ²¡æœ‰æä¾›ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼‰
          usage: cpuUsage,
          temperature: Math.random() * 20 + 45 // 45-65Â°Cï¼ˆåç«¯APIæ²¡æœ‰æä¾›ï¼Œä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼‰
        },
        memory: {
          total: status.system_info.total_memory,
          used: status.system_info.used_memory,
          available: status.system_info.total_memory - status.system_info.used_memory,
          usage_percent: memoryUsagePercent,
          swap_total: status.system_info.total_swap,
          swap_used: status.system_info.used_swap
        },
        gpu: gpu
      },
      network,
      disk: disks
    };
  };

  // è·å–æ¨¡æ‹Ÿç³»ç»Ÿä¿¡æ¯æ•°æ®
  const getMockSystemInfo = async (): Promise<SystemInfo> => {
    // è·å–çœŸå®çš„ç³»ç»Ÿä¿¡æ?
    const osName = window.navigator.platform;
    const hostname = window.location.hostname || 'localhost';

    // ç›´æ¥ä½¿ç”¨ç¡¬ç¼–ç çš„GPUä¿¡æ¯ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»çŸ¥é“ç³»ç»Ÿæœ‰NVIDIA GeForce RTX 3060
    const gpuInfo: GpuInfo[] = [
      {
        name: "NVIDIA GeForce RTX 3060",
        vendor: "NVIDIA",
        memory: 4 * 1024 * 1024 * 1024, // 4GB
        temperature: 68.3, // ä½¿ç”¨å›ºå®šæ¸©åº¦
        usage: 45.7 // ä½¿ç”¨å›ºå®šä½¿ç”¨ç?
      }
    ];

    console.log('ä½¿ç”¨ç¡¬ç¼–ç çš„GPUä¿¡æ¯:', gpuInfo);

    // å°è¯•è·å–çœŸå®çš„ç½‘ç»œæ¥å£ä¿¡æ?
    let networkInterfaces: NetworkInterface[] = [];
    let activeConnections = 0;
    let totalBytesSent = 0;
    let totalBytesReceived = 0;

    try {
      // ä½¿ç”¨invokeè°ƒç”¨run_commandæ‰§è¡Œipconfigå‘½ä»¤è·å–ç½‘ç»œä¿¡æ¯
      const ipconfigOutput = await invoke<string>('run_command', {
        command: 'ipconfig',
        args: ['/all']
      });

      console.log('ç½‘ç»œä¿¡æ¯åŸå§‹è¾“å‡º:', ipconfigOutput);

      // è§£æipconfigè¾“å‡º
      const lines = ipconfigOutput.split('\n');
      let currentInterface: NetworkInterface | null = null;

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();

        // æ£€æµ‹æ–°çš„ç½‘ç»œæ¥å£æ®µè?
        if (line.endsWith(':') && !line.startsWith(' ')) {
          // ä¿å­˜ä¹‹å‰çš„æ¥å?
          if (currentInterface) {
            networkInterfaces.push(currentInterface);
          }

          // åˆ›å»ºæ–°çš„æ¥å£
          const name = line.replace(':', '').trim();
          currentInterface = {
            name,
            display_name: name,
            is_up: false,
            is_loopback: name.toLowerCase().includes('loopback'),
            mac_address: '00:00:00:00:00:00',
            ip_addresses: [],
            transmitted_bytes: Math.random() * 1024 * 1024 * 100, // æ¨¡æ‹Ÿæ•°æ®
            received_bytes: Math.random() * 1024 * 1024 * 200, // æ¨¡æ‹Ÿæ•°æ®
            speed: 1000000000 // é»˜è®¤1Gbps
          };
        }

        // è§£ææ¥å£è¯¦ç»†ä¿¡æ¯
        if (currentInterface) {
          // æ£€æŸ¥æè¿°ä¿¡æ¯ï¼ˆæ˜¾ç¤ºåç§°ï¼?
          if (line.includes('Description')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              currentInterface.display_name = parts[1].trim();
            }
          }

          // æ£€æŸ¥ç‰©ç†åœ°å€ï¼ˆMACåœ°å€ï¼?
          if (line.includes('Physical Address')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              currentInterface.mac_address = parts[1].trim();
            }
          }

          // æ£€æŸ¥IPv4åœ°å€
          if (line.includes('IPv4 Address')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              const ip = parts[1].trim().replace('(Preferred)', '').trim();
              currentInterface.ip_addresses.push(ip);
              currentInterface.is_up = true;
              activeConnections++;
            }
          }

          // æ£€æŸ¥IPv6åœ°å€
          if (line.includes('IPv6 Address')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              // IPv6åœ°å€å¯èƒ½åŒ…å«å¤šä¸ªå†’å·ï¼Œéœ€è¦ç‰¹æ®Šå¤„ç?
              const ipParts = line.split(': ');
              if (ipParts.length > 1) {
                const ip = ipParts[1].trim().replace('(Preferred)', '').trim();
                currentInterface.ip_addresses.push(ip);
                currentInterface.is_up = true;
              }
            }
          }

          // æ£€æŸ¥è¿æ¥çŠ¶æ€?
          if (line.includes('Media State')) {
            const parts = line.split(':');
            if (parts.length > 1) {
              currentInterface.is_up = !parts[1].trim().includes('disconnected');
            }
          }
        }
      }

      // ä¿å­˜æœ€åä¸€ä¸ªæ¥å?
      if (currentInterface) {
        networkInterfaces.push(currentInterface);
      }

      // å°è¯•è·å–æ— çº¿ç½‘ç»œä¿¡æ¯
      try {
        const wirelessInfo = await getWirelessNetworkInfo();
        if (wirelessInfo.connected && wirelessInfo.ssid) {
          // æŸ¥æ‰¾Wi-Fiæ¥å£
          const wifiInterface = networkInterfaces.find(iface =>
            iface.name.toLowerCase().includes('wi-fi') ||
            iface.name.toLowerCase().includes('wlan') ||
            iface.display_name.toLowerCase().includes('wi-fi')
          );

          if (wifiInterface) {
            wifiInterface.display_name = `Wi-Fi (${wirelessInfo.ssid})`;
          }
        }
      } catch (err) {
        console.error('è·å–æ— çº¿ç½‘ç»œåç§°å¤±è´¥:', err);
      }

      // è®¡ç®—æ€»æµé‡?
      for (const iface of networkInterfaces) {
        totalBytesSent += iface.transmitted_bytes;
        totalBytesReceived += iface.received_bytes;
      }

      // å¦‚æœæ²¡æœ‰æ´»è·ƒè¿æ¥ï¼Œè®¾ç½®ä¸€ä¸ªé»˜è®¤å€?
      if (activeConnections === 0) {
        activeConnections = 5;
      }
    } catch (err) {
      console.error('è·å–ç½‘ç»œä¿¡æ¯å¤±è´¥:', err);
      // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç½‘ç»œä¿¡æ?
      networkInterfaces = [
        {
          name: 'eth0',
          display_name: 'ä»¥å¤ªç½?,
          is_up: true,
          is_loopback: false,
          mac_address: '00:00:00:00:00:00',
          ip_addresses: ['192.168.1.100'],
          transmitted_bytes: 1024 * 1024 * 100, // 100MB
          received_bytes: 1024 * 1024 * 500, // 500MB
          speed: 1000000000 // 1Gbps
        },
        {
          name: 'wlan0',
          display_name: 'Wi-Fi',
          is_up: false,
          is_loopback: false,
          mac_address: '00:00:00:00:00:00',
          ip_addresses: [],
          transmitted_bytes: 0,
          received_bytes: 0,
          speed: 0
        }
      ];
      activeConnections = 25;
      totalBytesSent = 1024 * 1024 * 200; // 200MB
      totalBytesReceived = 1024 * 1024 * 800; // 800MB
    }

    // å°è¯•è·å–çœŸå®çš„ç£ç›˜ä¿¡æ?
    let disks: DiskInfo[] = [];
    try {
      // ä½¿ç”¨invokeè°ƒç”¨run_commandæ‰§è¡Œwmicå‘½ä»¤è·å–ç£ç›˜ä¿¡æ¯
      const wmicOutput = await invoke<string>('run_command', {
        command: 'wmic',
        args: ['logicaldisk', 'get', 'caption,freespace,size,filesystem']
      });

      console.log('ç£ç›˜ä¿¡æ¯åŸå§‹è¾“å‡º:', wmicOutput);

      // è§£æwmicè¾“å‡º
      const lines = wmicOutput.split('\n')
        .filter(line => line.trim().length > 0)
        .slice(1); // è·³è¿‡æ ‡é¢˜è¡?

      for (const line of lines) {
        // åˆ†å‰²å¹¶è¿‡æ»¤ç©ºå­—ç¬¦ä¸?
        const parts = line.split(/\s{2,}/).filter(part => part.trim().length > 0);

        if (parts.length >= 3) {
          const name = parts[0].trim();
          const fileSystem = parts.length >= 4 ? parts[3].trim() : 'Unknown';

          // è§£æç©ºé—´å¤§å°
          let totalSpace = 0;
          let availableSpace = 0;

          if (parts.length >= 3) {
            const sizeStr = parts[2].trim();
            const freeSpaceStr = parts[1].trim();

            const parsedSize = parseInt(sizeStr);
            const parsedFreeSpace = parseInt(freeSpaceStr);

            if (!isNaN(parsedSize)) {
              totalSpace = parsedSize;
            }

            if (!isNaN(parsedFreeSpace)) {
              availableSpace = parsedFreeSpace;
            }
          }

          const usedSpace = totalSpace - availableSpace;
          const usagePercent = totalSpace > 0 ? (usedSpace / totalSpace) * 100 : 0;

          disks.push({
            name,
            mount_point: name + '\\',
            file_system: fileSystem,
            total_space: totalSpace,
            available_space: availableSpace,
            used_space: usedSpace,
            usage_percent: usagePercent,
            is_removable: false // æ— æ³•ä»wmicè¾“å‡ºç¡®å®š
          });
        }
      }
    } catch (err) {
      console.error('è·å–ç£ç›˜ä¿¡æ¯å¤±è´¥:', err);
      // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ç£ç›˜ä¿¡æ?
      disks = [
        {
          name: 'C:',
          mount_point: 'C:\\',
          file_system: 'NTFS',
          total_space: 1024 * 1024 * 1024 * 1024, // 1TB
          available_space: 1024 * 1024 * 1024 * 512, // 512GB
          used_space: 1024 * 1024 * 1024 * 512, // 512GB
          usage_percent: 50,
          is_removable: false
        },
        {
          name: 'D:',
          mount_point: 'D:\\',
          file_system: 'NTFS',
          total_space: 1024 * 1024 * 1024 * 2048, // 2TB
          available_space: 1024 * 1024 * 1024 * 1536, // 1.5TB
          used_space: 1024 * 1024 * 1024 * 512, // 512GB
          usage_percent: 25,
          is_removable: false
        }
      ];
    }

    return {
      os: {
        name: osName.includes('Win') ? 'Windows 11' : osName,
        version: '22H2',
        kernel_version: '10.0.22621',
        architecture: navigator.userAgent.includes('x64') ? 'x86_64' : 'x86',
        hostname: hostname === 'localhost' ? 'DESKTOP-PC' : hostname,
        uptime: 86400, // 1å¤?
        boot_time: Date.now() / 1000 - 86400
      },
      hardware: {
        cpu: {
          brand: 'Intel Core i7-12700K',
          cores: 12,
          frequency: 3600000000, // 3.6 GHz
          usage: Math.random() * 30 + 10, // 10-40%
          temperature: Math.random() * 20 + 45 // 45-65Â°C
        },
        memory: {
          total: 32 * 1024 * 1024 * 1024, // 32GB
          used: 16 * 1024 * 1024 * 1024, // 16GB
          available: 16 * 1024 * 1024 * 1024, // 16GB
          usage_percent: 50,
          swap_total: 4 * 1024 * 1024 * 1024, // 4GB
          swap_used: 1024 * 1024 * 1024 // 1GB
        },
        gpu: gpuInfo
      },
      network: {
        interfaces: networkInterfaces,
        active_connections: activeConnections,
        total_bytes_sent: totalBytesSent,
        total_bytes_received: totalBytesReceived
      },
      disk: disks
    };
  };

  const handleRefresh = () => {
    fetchSystemInfo();
  };

  if (loading && !systemInfo) {
    return <LoadingSpinner message="æ­£åœ¨è·å–ç³»ç»Ÿä¿¡æ¯..." />;
  }

  if (error && !systemInfo) {
    return (
      <div className="content-container">
        <h2 className="text-2xl font-bold mb-4">ğŸ“Š ç³»ç»Ÿä»ªè¡¨ç›?/h2>
        <div className="error-message">
          <p>{error}</p>
          <button
            className="btn btn-primary mt-2"
            onClick={handleRefresh}
          >
            é‡è¯•
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="content-container">
      <div className="flex justify-between items-center mb-6">
        <h2 className="text-2xl font-bold">ğŸ“Š ç³»ç»Ÿä»ªè¡¨ç›?/h2>
        <div className="flex items-center space-x-4">
          <span className="text-sm text-gray-500">
            æœ€åæ›´æ–? {lastUpdate.toLocaleTimeString()}
          </span>
          <button
            className="btn btn-primary"
            onClick={handleRefresh}
            disabled={loading}
          >
            ğŸ”„ {loading ? 'åˆ·æ–°ä¸?..' : 'åˆ·æ–°'}
          </button>
        </div>
      </div>

      {error && (
        <div className="bg-yellow-50 border-l-4 border-yellow-500 p-4 mb-6">
          <p className="text-yellow-700">{error}</p>
        </div>
      )}

      {systemInfo && (
        <div className="space-y-6">
          {/* ç³»ç»Ÿæ¦‚è§ˆ */}
          <SystemOverview systemInfo={systemInfo} />

          {/* ç¡¬ä»¶ç›‘æ§ */}
          <HardwareMonitor hardware={systemInfo.hardware} />

          {/* ç½‘ç»œçŠ¶æ€å’Œç£ç›˜ä½¿ç”¨æƒ…å†µ */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <NetworkStatus network={systemInfo.network} />
            <DiskUsage disks={systemInfo.disk} />
          </div>
        </div>
      )}
    </div>
  );
};

export default SystemDashboard;

